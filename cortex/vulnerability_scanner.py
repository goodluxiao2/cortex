#!/usr/bin/env python3
"""
Vulnerability Scanner for Cortex Linux

Continuously monitors installed packages for security vulnerabilities by checking
against CVE databases (NVD, OSV, Safety DB) and provides detailed vulnerability reports.
"""

import json
import logging
import subprocess
import sys
import time
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path

import requests

from cortex.progress_indicators import ProgressIndicator, get_progress_indicator
from cortex.utils.db_pool import SQLiteConnectionPool, get_connection_pool

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Severity(Enum):
    """CVE severity levels"""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    UNKNOWN = "unknown"


@dataclass
class Vulnerability:
    """Represents a security vulnerability"""

    cve_id: str
    package_name: str
    installed_version: str
    affected_versions: str
    severity: Severity
    description: str
    published_date: str | None = None
    fixed_version: str | None = None
    cvss_score: float | None = None
    source: str = "unknown"
    references: list[str] = None

    def __post_init__(self):
        if self.references is None:
            self.references = []


@dataclass
class ScanResult:
    """Result of a vulnerability scan"""

    scan_id: str
    timestamp: str
    total_packages_scanned: int
    vulnerabilities_found: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    vulnerabilities: list[Vulnerability]
    scan_duration_seconds: float
    errors: list[str] = None

    def __post_init__(self):
        if self.errors is None:
            self.errors = []


class VulnerabilityScanner:
    """Scans installed packages for security vulnerabilities"""

    def __init__(self, db_path: str | None = None):
        if db_path is None:
            db_path = str(Path.home() / ".cortex" / "vulnerability_cache.db")

        self.db_path = db_path
        self._ensure_db_directory()
        self._pool: SQLiteConnectionPool | None = None
        self._init_database()

        # API endpoints
        self.osv_api = "https://api.osv.dev/v1/query"
        self.nvd_api = "https://services.nvd.nist.gov/rest/json/cves/2.0"

        # Rate limiting
        self.last_api_call = 0.0
        self.min_api_interval = 0.5

    def _ensure_db_directory(self):
        db_dir = Path(self.db_path).parent
        db_dir.mkdir(parents=True, exist_ok=True)

    def _init_database(self):
        try:
            self._pool = get_connection_pool(self.db_path, pool_size=3)

            with self._pool.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS vulnerability_cache (
                        package_name TEXT,
                        version TEXT,
                        cve_id TEXT,
                        severity TEXT,
                        cached_at TEXT,
                        expires_at TEXT,
                        data TEXT,
                        PRIMARY KEY (package_name, version, cve_id)
                    )
                """)

                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS scan_history (
                        scan_id TEXT PRIMARY KEY,
                        timestamp TEXT NOT NULL,
                        total_packages INTEGER,
                        vulnerabilities_found INTEGER,
                        scan_duration REAL,
                        result_json TEXT
                    )
                """)

                cursor.execute("""
                    CREATE INDEX IF NOT EXISTS idx_cache_expires
                    ON vulnerability_cache(expires_at)
                """)
                cursor.execute("""
                    CREATE INDEX IF NOT EXISTS idx_scan_timestamp
                    ON scan_history(timestamp)
                """)

                conn.commit()

            logger.info(f"Vulnerability database initialized at {self.db_path}")
        except Exception as e:
            logger.error(f"Failed to initialize database: {e}")
            raise

    def _rate_limit(self):
        elapsed = time.time() - self.last_api_call
        if elapsed < self.min_api_interval:
            time.sleep(self.min_api_interval - elapsed)
        self.last_api_call = time.time()

    def _parse_cvss_vector(self, vector_string: str) -> float | None:
        """Parse a CVSS vector string and estimate a severity score."""
        if not vector_string or not vector_string.startswith("CVSS:"):
            return None

        try:
            parts = vector_string.split("/")
            metrics = {}
            for part in parts[1:]:
                if ":" in part:
                    key, value = part.split(":", 1)
                    metrics[key] = value

            score = 0.0
            av_scores = {"N": 2.5, "A": 2.0, "L": 1.5, "P": 1.0}
            score += av_scores.get(metrics.get("AV", "L"), 1.5)

            ac_scores = {"L": 1.5, "H": 0.5}
            score += ac_scores.get(metrics.get("AC", "L"), 1.0)

            pr_scores = {"N": 1.5, "L": 1.0, "H": 0.5}
            score += pr_scores.get(metrics.get("PR", "L"), 1.0)

            impact_scores = {"H": 1.5, "L": 0.75, "N": 0.0}
            score += impact_scores.get(metrics.get("C", "N"), 0.5)
            score += impact_scores.get(metrics.get("I", "N"), 0.5)
            score += impact_scores.get(metrics.get("A", "N"), 0.5)

            return min(10.0, max(0.0, score))

        except Exception as e:
            logger.debug(f"Failed to parse CVSS vector '{vector_string}': {e}")
            return None

    def _get_installed_packages(self) -> dict[str, str]:
        packages = {}

        try:
            result = subprocess.run(
                ["dpkg-query", "-W", "-f=${Package}|${Version}\n"],
                capture_output=True,
                text=True,
                timeout=30,
            )

            if result.returncode == 0:
                for line in result.stdout.strip().split("\n"):
                    if "|" in line:
                        parts = line.split("|", 1)
                        if len(parts) == 2:
                            packages[parts[0].strip()] = parts[1].strip()

            logger.info(f"Found {len(packages)} installed packages")
        except Exception as e:
            logger.error(f"Failed to get installed packages: {e}")

        return packages

    def _vulnerability_to_dict(self, vuln: Vulnerability) -> dict:
        return {
            "cve_id": vuln.cve_id,
            "package_name": vuln.package_name,
            "installed_version": vuln.installed_version,
            "affected_versions": vuln.affected_versions,
            "severity": vuln.severity.value,
            "description": vuln.description,
            "published_date": vuln.published_date,
            "fixed_version": vuln.fixed_version,
            "cvss_score": vuln.cvss_score,
            "source": vuln.source,
            "references": vuln.references or [],
        }

    def _dict_to_vulnerability(self, data: dict) -> Vulnerability:
        severity = data.get("severity", "unknown")
        if isinstance(severity, str):
            try:
                severity = Severity(severity)
            except ValueError:
                severity = Severity.UNKNOWN

        return Vulnerability(
            cve_id=data.get("cve_id", ""),
            package_name=data.get("package_name", ""),
            installed_version=data.get("installed_version", ""),
            affected_versions=data.get("affected_versions", ""),
            severity=severity,
            description=data.get("description", ""),
            published_date=data.get("published_date"),
            fixed_version=data.get("fixed_version"),
            cvss_score=data.get("cvss_score"),
            source=data.get("source", "unknown"),
            references=data.get("references", []),
        )

    def _check_cache(self, package_name: str, version: str) -> list[Vulnerability] | None:
        try:
            with self._pool.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute(
                    "SELECT data, expires_at FROM vulnerability_cache WHERE package_name = ? AND version = ?",
                    (package_name, version),
                )

                rows = cursor.fetchall()
                if not rows:
                    return None

                vulnerabilities = []
                expired_found = False
                now = datetime.now()

                for row in rows:
                    expires_at = datetime.fromisoformat(row[1])
                    if now < expires_at:
                        # Cache entry is valid
                        data = json.loads(row[0])
                        if isinstance(data, dict):
                            vulnerabilities.append(self._dict_to_vulnerability(data))
                        elif isinstance(data, list):
                            for v in data:
                                if isinstance(v, dict):
                                    vulnerabilities.append(self._dict_to_vulnerability(v))
                    else:
                        # Mark that we found expired entries
                        expired_found = True

                # Delete all expired entries for this package/version
                if expired_found:
                    cursor.execute(
                        "DELETE FROM vulnerability_cache WHERE package_name = ? AND version = ? AND expires_at < ?",
                        (package_name, version, now.isoformat()),
                    )
                    conn.commit()

                # Return aggregated list if non-empty, otherwise None
                return vulnerabilities if vulnerabilities else None

        except Exception as e:
            logger.warning(f"Cache check failed: {e}")

        return None

    def _save_cache(self, package_name: str, version: str, vulnerabilities: list[Vulnerability]):
        try:
            with self._pool.get_connection() as conn:
                cursor = conn.cursor()

                cached_at = datetime.now()
                expires_at = cached_at + timedelta(hours=24)

                for vuln in vulnerabilities:
                    vuln_dict = self._vulnerability_to_dict(vuln)
                    cursor.execute(
                        "INSERT OR REPLACE INTO vulnerability_cache VALUES (?, ?, ?, ?, ?, ?, ?)",
                        (
                            package_name,
                            version,
                            vuln.cve_id,
                            vuln.severity.value,
                            cached_at.isoformat(),
                            expires_at.isoformat(),
                            json.dumps(vuln_dict),
                        ),
                    )

                conn.commit()
        except Exception as e:
            logger.warning(f"Failed to save cache: {e}")

    def _query_osv(self, package_name: str, version: str) -> list[Vulnerability]:
        vulnerabilities = []

        try:
            self._rate_limit()

            query = {
                "package": {"name": package_name, "ecosystem": "Debian"},
                "version": version,
            }

            response = requests.post(
                self.osv_api, json=query, timeout=10, headers={"Content-Type": "application/json"}
            )

            if response.status_code == 200:
                data = response.json()
                if "vulns" in data:
                    for vuln in data["vulns"]:
                        severity = Severity.UNKNOWN
                        cvss_score = None

                        if "database_specific" in vuln:
                            db_spec = vuln["database_specific"]
                            if "severity" in db_spec:
                                sev_str = db_spec["severity"].upper()
                                if sev_str in ["CRITICAL", "CRIT"]:
                                    severity = Severity.CRITICAL
                                elif sev_str == "HIGH":
                                    severity = Severity.HIGH
                                elif sev_str == "MEDIUM":
                                    severity = Severity.MEDIUM
                                elif sev_str == "LOW":
                                    severity = Severity.LOW

                        if "severity" in vuln:
                            for sev in vuln["severity"]:
                                if sev["type"] == "CVSS_V3":
                                    score_value = sev.get("score", "")
                                    if isinstance(score_value, (int, float)):
                                        cvss_score = float(score_value)
                                    elif isinstance(score_value, str):
                                        try:
                                            cvss_score = float(score_value)
                                        except ValueError:
                                            cvss_score = self._parse_cvss_vector(score_value)

                                    if cvss_score is not None:
                                        if cvss_score >= 9.0:
                                            severity = Severity.CRITICAL
                                        elif cvss_score >= 7.0:
                                            severity = Severity.HIGH
                                        elif cvss_score >= 4.0:
                                            severity = Severity.MEDIUM
                                        else:
                                            severity = Severity.LOW

                        affected = "unknown"
                        fixed_version = None
                        if "affected" in vuln:
                            for affected_range in vuln["affected"]:
                                if "ranges" in affected_range:
                                    for range_item in affected_range["ranges"]:
                                        if "events" in range_item:
                                            affected = str(range_item["events"])
                                            for event in range_item["events"]:
                                                if "fixed" in event:
                                                    fixed_version = event["fixed"]

                        references = []
                        if "references" in vuln:
                            for ref in vuln["references"]:
                                if "url" in ref:
                                    references.append(ref["url"])

                        vuln_obj = Vulnerability(
                            cve_id=vuln.get("id", "UNKNOWN"),
                            package_name=package_name,
                            installed_version=version,
                            affected_versions=affected,
                            severity=severity,
                            description=vuln.get("summary", "No description available"),
                            published_date=vuln.get("published", ""),
                            fixed_version=fixed_version,
                            cvss_score=cvss_score,
                            source="osv",
                            references=references,
                        )

                        vulnerabilities.append(vuln_obj)

        except requests.RequestException as e:
            logger.warning(f"OSV query failed for {package_name}: {e}")
        except Exception as e:
            logger.warning(f"Error processing OSV response: {e}")

        return vulnerabilities

    def scan_package(self, package_name: str, version: str) -> list[Vulnerability]:
        cached = self._check_cache(package_name, version)
        if cached is not None:
            return cached

        vulnerabilities = self._query_osv(package_name, version)

        if vulnerabilities:
            self._save_cache(package_name, version, vulnerabilities)

        return vulnerabilities

    def scan_all_packages(
        self,
        package_filter: list[str] | None = None,
        progress: ProgressIndicator | None = None,
    ) -> ScanResult:
        start_time = time.time()
        scan_id = f"scan_{int(start_time)}"

        logger.info("Starting vulnerability scan...")

        installed_packages = self._get_installed_packages()

        if package_filter:
            installed_packages = {k: v for k, v in installed_packages.items() if k in package_filter}

        total_packages = len(installed_packages)
        all_vulnerabilities = []
        errors = []

        logger.info(f"Scanning {total_packages} packages...")

        # Use provided progress indicator or get global one
        if progress is None:
            progress = get_progress_indicator()

        # Convert packages to list for progress bar iteration
        package_items = list(installed_packages.items())

        for package_name, version in progress.progress_bar(
            package_items, description=f"üîç Scanning {total_packages} packages"
        ):
            try:
                vulns = self.scan_package(package_name, version)
                if vulns:
                    # Log vulnerabilities found using progress indicator
                    progress.print_warning(
                        f"{package_name}: {len(vulns)} vulnerability(ies) found"
                    )
                all_vulnerabilities.extend(vulns)
            except Exception as e:
                error_msg = f"Failed to scan {package_name}: {e}"
                logger.error(error_msg)
                errors.append(error_msg)

        critical_count = sum(1 for v in all_vulnerabilities if v.severity == Severity.CRITICAL)
        high_count = sum(1 for v in all_vulnerabilities if v.severity == Severity.HIGH)
        medium_count = sum(1 for v in all_vulnerabilities if v.severity == Severity.MEDIUM)
        low_count = sum(1 for v in all_vulnerabilities if v.severity == Severity.LOW)

        scan_duration = time.time() - start_time

        result = ScanResult(
            scan_id=scan_id,
            timestamp=datetime.now().isoformat(),
            total_packages_scanned=total_packages,
            vulnerabilities_found=len(all_vulnerabilities),
            critical_count=critical_count,
            high_count=high_count,
            medium_count=medium_count,
            low_count=low_count,
            vulnerabilities=all_vulnerabilities,
            scan_duration_seconds=scan_duration,
            errors=errors,
        )

        self._save_scan_history(result)

        logger.info(f"Scan complete: {len(all_vulnerabilities)} vulnerabilities found in {scan_duration:.2f}s")

        return result

    def _save_scan_history(self, result: ScanResult):
        try:
            with self._pool.get_connection() as conn:
                cursor = conn.cursor()

                result_dict = {
                    "scan_id": result.scan_id,
                    "timestamp": result.timestamp,
                    "total_packages_scanned": result.total_packages_scanned,
                    "vulnerabilities_found": result.vulnerabilities_found,
                    "critical_count": result.critical_count,
                    "high_count": result.high_count,
                    "medium_count": result.medium_count,
                    "low_count": result.low_count,
                    "vulnerabilities": [self._vulnerability_to_dict(v) for v in result.vulnerabilities],
                    "scan_duration_seconds": result.scan_duration_seconds,
                    "errors": result.errors or [],
                }

                cursor.execute(
                    "INSERT OR REPLACE INTO scan_history VALUES (?, ?, ?, ?, ?, ?)",
                    (
                        result.scan_id,
                        result.timestamp,
                        result.total_packages_scanned,
                        result.vulnerabilities_found,
                        result.scan_duration_seconds,
                        json.dumps(result_dict),
                    ),
                )

                conn.commit()
        except Exception as e:
            logger.warning(f"Failed to save scan history: {e}")

    def get_scan_history(self, limit: int = 10) -> list[ScanResult]:
        results = []

        try:
            with self._pool.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute(
                    "SELECT result_json FROM scan_history ORDER BY timestamp DESC LIMIT ?",
                    (limit,),
                )

                for row in cursor.fetchall():
                    data = json.loads(row[0])
                    vulns = [self._dict_to_vulnerability(v) if isinstance(v, dict) else v for v in data.get("vulnerabilities", [])]
                    data["vulnerabilities"] = vulns
                    results.append(ScanResult(**data))

        except Exception as e:
            logger.error(f"Failed to get scan history: {e}")

        return results

    def get_critical_vulnerabilities(self, days: int = 30) -> list[Vulnerability]:
        all_critical = []

        try:
            cutoff = datetime.now() - timedelta(days=days)
            cutoff_str = cutoff.isoformat()

            with self._pool.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute(
                    "SELECT result_json FROM scan_history WHERE timestamp >= ? ORDER BY timestamp DESC",
                    (cutoff_str,),
                )

                for row in cursor.fetchall():
                    data = json.loads(row[0])
                    vulns = [self._dict_to_vulnerability(v) if isinstance(v, dict) else v for v in data.get("vulnerabilities", [])]
                    critical = [v for v in vulns if v.severity == Severity.CRITICAL]
                    all_critical.extend(critical)

        except Exception as e:
            logger.error(f"Failed to get critical vulnerabilities: {e}")

        seen = set()
        unique_critical = []
        for vuln in all_critical:
            if vuln.cve_id not in seen:
                seen.add(vuln.cve_id)
                unique_critical.append(vuln)

        return unique_critical


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Scan packages for security vulnerabilities")
    parser.add_argument("--package", help="Scan specific package")
    parser.add_argument("--all", action="store_true", help="Scan all installed packages")
    parser.add_argument("--history", type=int, help="Show scan history (last N scans)")
    parser.add_argument("--critical", action="store_true", help="Show only critical vulnerabilities")

    args = parser.parse_args()

    scanner = VulnerabilityScanner()

    if args.history:
        history = scanner.get_scan_history(args.history)
        print(f"\nüìä Scan History (last {args.history} scans):")
        print("=" * 80)
        for scan in history:
            print(f"\nScan ID: {scan.scan_id}")
            print(f"Date: {scan.timestamp}")
            print(f"Packages scanned: {scan.total_packages_scanned}")
            print(f"Vulnerabilities: {scan.vulnerabilities_found}")
            print(f"  Critical: {scan.critical_count}, High: {scan.high_count}")
            print(f"  Medium: {scan.medium_count}, Low: {scan.low_count}")

    elif args.critical:
        critical = scanner.get_critical_vulnerabilities()
        print("\nüî¥ Critical Vulnerabilities:")
        print("=" * 80)
        for vuln in critical:
            print(f"\nCVE: {vuln.cve_id}")
            print(f"Package: {vuln.package_name} {vuln.installed_version}")
            print(f"Description: {vuln.description[:100]}...")
            if vuln.fixed_version:
                print(f"Fixed in: {vuln.fixed_version}")

    elif args.package:
        packages = scanner._get_installed_packages()
        if args.package not in packages:
            print(f"‚ùå Package {args.package} not found")
            sys.exit(1)

        version = packages[args.package]
        vulns = scanner.scan_package(args.package, version)

        print(f"\nüîç Vulnerabilities for {args.package} {version}:")
        print("=" * 80)
        if vulns:
            for vuln in vulns:
                print(f"\nCVE: {vuln.cve_id} [{vuln.severity.value.upper()}]")
                print(f"Description: {vuln.description}")
                if vuln.fixed_version:
                    print(f"Fixed in: {vuln.fixed_version}")
        else:
            print("‚úÖ No vulnerabilities found")

    elif args.all:
        result = scanner.scan_all_packages()

        print("\nüìä Scan Results:")
        print("=" * 80)
        print(f"Packages scanned: {result.total_packages_scanned}")
        print(f"Vulnerabilities found: {result.vulnerabilities_found}")
        print(f"  üî¥ Critical: {result.critical_count}")
        print(f"  üü† High: {result.high_count}")
        print(f"  üü° Medium: {result.medium_count}")
        print(f"  üü¢ Low: {result.low_count}")
        print(f"\nScan duration: {result.scan_duration_seconds:.2f}s")

        if result.vulnerabilities:
            print("\nüìã Top Vulnerabilities:")
            sorted_vulns = sorted(
                result.vulnerabilities,
                key=lambda v: (
                    v.severity == Severity.CRITICAL,
                    v.severity == Severity.HIGH,
                    v.cvss_score or 0,
                ),
                reverse=True,
            )

            for vuln in sorted_vulns[:10]:
                print(f"\n  {vuln.cve_id} - {vuln.package_name} [{vuln.severity.value.upper()}]")
                print(f"    {vuln.description[:80]}...")

    else:
        parser.print_help()
